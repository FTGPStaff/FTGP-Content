# 📒 PeopleBook Tutorial – Combining Structs, Arrays, and Mappings

> 📘 **Goal:** Learn how to combine `struct`, `array`, and `mapping` to build a mini on-chain directory ("PeopleBook") and practice storing and retrieving structured user data.

---

## 🔧 What We’ll Build

We will create a `PeopleBook` contract that:

- Stores a list of `Person` structs in an array
- Allows fast lookup of people by name using a mapping
- Supports adding new people and retrieving their data

Useful for understanding real-world dApp patterns like address books, user registries, and basic CRUD logic.

---

## 🧱 Step 1: Define Your Struct and Storage

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.8;

contract PeopleBook {
    struct Person {
        string name;
        uint256 age;
    }

    Person[] public people;
    mapping(string => Person) public nameToPerson;
```

### 🔍 Explanation

- `struct Person` defines our contact structure.
- `people[]` is a dynamic array to store everyone.
- `mapping` allows quick lookup by name.

---

## ✍️ Step 2: Add a Person

```solidity
function addPerson(string memory _name, uint256 _age) public {
    Person memory newPerson = Person(_name, _age);
    people.push(newPerson);
    nameToPerson[_name] = newPerson;
}
```

### ✅ What it does:

- Creates a `Person` object from input
- Stores it in the array
- Maps the name to the struct for fast lookup

---

## 🔍 Step 3: Get Data Back

```solidity
function getPersonByIndex(uint256 index) public view returns (string memory, uint256) {
    Person memory p = people[index];
    return (p.name, p.age);
}

function getPersonByName(string memory _name) public view returns (string memory, uint256) {
    Person memory p = nameToPerson[_name];
    return (p.name, p.age);
}
```

## 🧪 Example Usage

1. Deploy the contract in Remix (JavaScript VM)
2. Call `addPerson("Alice", 30)`
3. Call `addPerson("Bob", 25)`
4. Try `getPersonByIndex(0)` → returns Alice
5. Try `getPersonByName("Bob")` → returns Bob

✅ `people[]` helps keep order  
✅ `mapping` gives fast access

---

## 🧠 Best Practices

- Always include memory keyword for string inputs  
- Make your mappings `public` to expose autogenerated getters  
- Avoid name collisions when using string keys  
- Consider enforcing uniqueness for names (e.g., via require checks)

---

## 🎯 Mini Exercise: Extend the PeopleBook

Add the following features:

- Include an email address in the `Person` struct  
- Add a `removePerson(string memory _name)` function that removes a person from the mapping only  
- Add a function `getPeopleCount()` that returns the number of people in the array

---

## ✅ Quiz

**Q1. What is the benefit of combining arrays and mappings?**  
✅ A) You get both order and fast access  
B) They both support iteration  
C) Only mappings can store structs  
D) Arrays auto-generate mapping entries

**Q2. What does `memory` keyword mean for function parameters?**  
✅ A) Temporary data used during function execution  
B) Data stored permanently on chain  
C) Can be updated across transactions  
D) Refers to calldata location

**Q3. What happens if you look up a mapping key that doesn’t exist?**  
✅ A) You get the default value of the value type  
B) The transaction fails  
C) The key is auto-added  
D) It reverts with an error

---

## 📚 Further Reading

- [Solidity Docs – Structs](https://docs.soliditylang.org/en/latest/types.html#structs)  
- [Solidity Docs – Mappings](https://docs.soliditylang.org/en/latest/types.html#mappings)  
- [Solidity by Example – Structs](https://solidity-by-example.org/structs/)

🎉 **Next Up:** Learn about gas optimizations with `view`, `pure`, and `calldata` in `01_view_pure_optimization.md`
